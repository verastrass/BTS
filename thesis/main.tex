\input{preamble.tex}
\NewBibliographyString{langjapanese}
\NewBibliographyString{fromjapanese}

\begin{document}
\floatname{algorithm}{Алгоритм}
\algnewcommand\algorithmicwait{\textbf{wait}}
\algnewcommand\Wait[2]{\algorithmicwait \: #1(#2)}

\algblock{Upon}{EndUpon}
\algnewcommand\algorithmicupon{\textbf{upon}}
\algnewcommand\algorithmicendupon{\textbf{end\ upon}}
\algrenewtext{Upon}[2]{\algorithmicupon \: #1(#2)}
\algrenewtext{EndUpon}{\algorithmicendupon}

\catcode`\_=\active

	
\Intro
В~современном мире распределённые системы являются основой различных объектов, например, веб-сервисов и пиринговых сетей. Поскольку обмен сообщениями в~системе осуществляется по~ненадёжным каналам связи, сообщения, посылаемые системе или самой системой, могут просматриваться, перехватываться и подменяться. Это приводит к~неправильному функционированию, отказу отдельных компонент или системы в~целом. Поэтому в~распределённых системах поддержке безопасности уделяется особое внимание.

Для~повышения надёжности системы случайные и умышленные сбои интерпретируются как Византийские ошибки (в~терминах задачи о~византийских генералах). В~этом случае можно использовать соответствующие отказоустойчивые техники, которые смогут защитить систему и от~случайных сбоев, и от~умышленных вторжений.

В~данной работе рассматривается византийское пространство кортежей~--- открытая распределённая устойчивая к~византийским ошибкам система, основанная на~пространстве кортежей без~распределённой памяти, в~которой процессы взаимодействуют путём~обмена сообщениями.

/здесь будет продолжение/

\pagebreak

\if 0
Для~того, чтобы поиск кортежей в~пространстве кортежей занимал минимальное время, адресация в~нём осуществляется по~содержимому (например, с~помощью алгоритмов хэширования). Иными словами, пространство кортежей~--- реализация парадигмы ассоциативной памяти.

$eval$~--- создание нового процесса для~обработки данных. Результаты работы этого процесса отразятся на~общем пространстве.

 


На~практике задача византийских генералов решается с~помощью алгоритмов консенсуса, ярким представителем которых является алгоритм $Paxos$, предложенный Лесли Лампортом.

\section{Paxos}\label{sec:2}
$Paxos$~--- это алгоритм для~решения задачи консенсуса в~сети ненадёжных вычислителей. Компоненты распределённой системы можно разделить на~три группы:
\begin{itemize}
	\item Заявитель ($Proposer$)~--- выдвигает <<предложения>> (какие-то значения), которые либо принимаются, либо отвергаются в~результате работы алгоритма.
	\item Акцептор ($Acceptor$)~--- принимает или отвергает <<предложение>> Заявителя, согласует своё решение с~остальными Акцепторами, уведомляет о~своём решении Узнающих. Если Акцепторами было принято какое-либо значение, предложенное Заявителем, то оно называется утверждённым.
	\item Узнающий ($Learner$)~--- запоминает решение Акцепторов, принятое в~результате работы алгоритма консенсуса.
\end{itemize}

Компоненты распределённой системы могут принадлежать сразу нескольким группам, описанным выше, и вести себя и как Заявитель, и как Акцептор, и как Узнающий. Такое распределение ролей в~системе гарантирует следующее:
\begin{itemize}
	\item Только предложенное Заявителем значение может быть утверждено Акцепторами.
	\item Акцепторами утверждается только одно значение из~всех предложенных Заявителями значений (возможно, противоречивых).
	\item Узнающий не~сможет узнать об~утверждении какого-либо значения вплоть до~того момента, пока оно действительно не~будет утверждено.
\end{itemize}

/здесь будет описание и графическая интерпретация алгоритма с Википедии/
\fi




\section{Распределённые вычислительные системы и отказоустойчивость}\label{sec:1}
Распределённая вычислительная система~--- это набор независимых компьютеров, реализующий параллельную обработку данных на~многих вычислительных узлах~\autocite{Tanenbaum}. С~точки зрения пользователя этот набор является единым механизмом, предоставляющим полный доступ к~ресурсам. Существует возможность добавления новых ресурсов и перераспределения их по~системе, возможность добавления свойст и методов, но информация об~этих событиях скрыта от~пользователя.

Одной из~важнейших характеристик распределённых систем является отказоустойчивость. Отказоустойчивость~--- это свойство системы сохранять работоспособность в~том случае, если какие-либо составляющие её компоненты перестали правильно функционировать~\autocite{Tanenbaum}. Компоненты системы могут стать нероботоспособны по~различным причинам, например, из-за~технологических сбоев или атак безопасности.

Большинство современных распределённых систем имеют характеристики открытых систем. Открытая распределённая система предполагает использование служб, вызов которых требует стандартного синтаксиса и семантики~\autocite{Kosyakov}. Такая система может иметь неизвестное количество ненадёжных и неоднородных участников, к~тому же участникам не~нужно быть активными одновременно (свойство разъединённости во~времени) и не~обязательно что-то знать друг о~друге (свойство разъединённости в~пространстве). Связь между~узлами распределённой системы является ненадёжной (может прерываться, что повлечёт за~собой потерю сообщений), обмен сообщениями может происходить не~мгновенно, а с~существенной задержкой. Кроме~того, любой узел системы может отказать или быть выключен в~любой момент времени. Все эти факторы неизбежно приводят к~неправильному функционированию системы.

Один из~способов улучшить её надёжность~--- это интерпретировать случайные или умышленные неполадки как~византийские ошибки (в~терминах задачи византийских генералов), тогда использование отказоустойчивых техник сможет сделать координационную составляющую системы отказоустойчивой и для~случайных сбоев, и для~умышленных вторжений.

Задача византийских генералов~--- это задача взаимодействия нескольких удалённых абонентов, получивших сообщения из~одного центра, причём часть этих абонентов, в~том числе центр, могут быть предателями, то~есть могут посылать заведомо ложные сообщения с~целью дезинформирования. Нахождение решения задачи заключается в~выработке единой стратегии действий, которая будет являться выигрышной для~всех абонентов~\autocite{byzgen}.

Формулировка задачи состоит в~следующем. Византийская армия представляет собой объединение некоторого числа легионов, каждым из~которых командует свой генерал, генералы подчиняются главнокомандующему армии Византии. Поскольку империя находится в~упадке, любой из~генералов и даже главнокомандующий могут быть заинтересованы в~поражении армии, то~есть являться предателями. Генералов, не~заинтересованных в~поражении армии, будем называть верными. В~ночь перед~сражением каждый из~генералов получает от~главнокомандующего приказ о~действиях во~время сражения: атаковать или отступать. Таким образом, имеем три возможных исхода сражения:
\begin{itemize}
	\item Благоприятный исход: все генералы атакуют противника, что приведёт к~его уничтожению и победе Византии.
	\item Промежуточный исход: все генералы отступят, тогда противник не~будет побеждён, но Византия сохранит свою армию.
	\item Неблагоприятный исход: некоторые генералы атакуют противника, некоторые отступят, тогда Византийская армии потерпит поражение.
\end{itemize}

Так~как главнокомандующий тоже может оказаться предателем, генералам не~следует доверять его приказам. Однако, если каждый генерал будет действовать самостоятельно, независимо от~других генералов, то вероятность наступления боагоприятного исхода становится низкой. Таким образом, генералам следует обмениваться информацией между~собой для~того, чтобы прийти к~единому решению.

В~данной работе рассматривается распределённая система под~названием <<Византийское пространство кортежей>> ($\mbox{BTS: Byzantine Tuple Space}$)~\autocite{bts}.


\section{BTS: Византийское пространство кортежей}\label{sec:2}
\subsection{Системная модель}\label{subsec:1}
Системная модель византийского пространства кортежей~$BTS$ предполагает бесконечное число процессов-клиентов $\Pi = \{p_1, p_2, \dots\}$, которые коммуницируют со~множеством из~$n$ серверов $U = \{s_1, s_2, \dots, s_n\}$ при~помощи обмена сообщениями.

Будем полагать, что случайное число клиентов и связка серверов из~$f \leqslant \left\lfloor \dfrac{n-1}{3} \right\rfloor$ штук могут быть подвержены византийским ошибкам: они могут произвольным образом отклоняться от~их спецификаций и работать в~сговоре, чтобы изменить поведение системы. Такие процессы будем называть неисправными, а правильно работающие процессы~--- корректными.

Основа распределённой системы~$BTS$~--- это пространство кортежей, которое также является ядром языка программирования~$Linda$~\autocite{linda}, предназначенного для~построения эффективных параллельных программ. Кортеж~--- это структура данных, представляющая собой неизменяемый список фиксированной длины, элементы которого могут относиться к~различным типам данных. Два кортежа $t_1$ и $t_2$ считаются идентичными, если совпадают их длины, а также типы и значения соответствующих полей. Хранилище кортежей, в~котором доступ к~элементам может осуществляться параллельно, называется пространством кортежей~\autocite{tuplespace}.

Каждый сервер~$s \in U$ при запуске получает на вход имя файла, в котором хранится содержимое пространства кортежей. Это необходимо для создания сервером~$s$ локальной копии пространства кортежей~$T_s$. Кроме того, создаётся изначально пустое множество кортежей для~удаления~$R_s$. Будем полагать, что идентичных кортежей в~пространстве не~существует, тогда к~двум описанным множествам кортежей могут быть применены стандартные операции над~множествами.

Для искусственной имитации неисправных серверов будем при запуске подавать им на вход файл с неправильным пространством кортежей. Таким образом, множества~$T_{s_1}$~и~$T_{s_2}$, принадлежащие корректному серверу~$s_1$ и неисправному серверу~$s_2$ соответственно, будут иметь пустое пересечение, что повлечёт за собой конфликты и позволит проверить отказоустойчивость системы.

Каждый сервер~$s$ реализует три операции манипулирования данными (кортежами), описанные в~языке~$Linda$:
\begin{itemize}
	\item $out$~--- запись кортежа в~пространство кортежей.
	\item $rd$~--- недеструктивное чтение кортежа.
	\item $in$~--- деструктивное чтение (извлечение) кортежа.
\end{itemize}
Определим такое понятие, как шаблон кортежа~--- это кортеж, некоторые поля которого неопределены и не~представляют важности. Будем говорить, что кортеж соответствует шаблону, если длина кортежа равна длине шаблона и определённые в~шаблоне поля совпадают по~типу и значению с~соответствующими полями кортежа.

Операция записи $out$ принимает в~качестве входного параметра кортеж, все поля которого определены. Операции чтения $rd$ и $in$ принимают в~качестве входного параметра шаблон кортежа, по~которому производится поиск соответствующих кортежей в~пространстве.

Благодаря наличию операций чтения/записи, пространство кортежей можно рассматривать как~разновидность распределённой памяти: например, одна группа процессов записывает данные в~пространство, а другая группа извлекает их и использует в~своей дальнейшей работе.

Распределённая система не может полагаться на какой-то один конкретный узел, так как в случае его отказа восстановить систему будет невозможно~\autocite{Kleppman}. Это означает, что выполнение любой операции манипулирования кортежами не может производиться только на одном из имеющихся узлов. Для решения этой проблемы разобьём множество $U$ на кворумы и получим кворум-систему, тогда каждая операция чтения/записи будет выполняться в соответствующем кворуме, что обеспечит правильное функционирование системы в случае отказа~$f$ узлов.

Кворум-система представляет собой множество кворумов серверов~$\mathcal{Q} \in 2^{U}$, в~котором каждая пара кворумов из~$\mathcal{Q}$ пересекается на~достаточно многих серверах и всегда есть кворум со~всеми корректными серверами. Существование пересечений между~кворумами позволяет совершенствовать протоколы чтения/записи, позволяя поддерживать целостность разделённой переменной, даже если эти операции были выполнены в~разных кворумах системы.

Будем полагать, что~$n > 3f + 1$. Разделим кворумы на~два типа~$(\mathcal{Q} = \mathcal{Q}_r \cup \mathcal{Q}_w)$:
\begin{itemize}
	\item кворумы чтения~$(Q_r \in \mathcal{Q}_r)$, мощность каждого кворума ~$|Q_r| = \left\lceil \dfrac{n+f+1}{2} \right\rceil$ серверов,
	\item кворумы записи~$(Q_w \in \mathcal{Q}_w)$, мощность каждого кворума~$|Q_w| = \left\lceil \dfrac{n+f+1}{2} \right\rceil + f$ серверов.
\end{itemize}
Так как~$|Q_r| + |Q_w| > n$, то можно ожидать, что полученное при чтении значение  будет наиболее актуальным, поскольку хотя бы один из узлов кворума~$|Q_r|$ также участвует в выплнении операции записи.

Взаимодействие клиентов с~системой происходит посредством вспомогательной промежуточной координационной инфраструктуры, как показано на~рисунке\,\ref{clser}.
\begin{figure}[H]
	\centering \includegraphics[width=0.7 \textwidth, height=0.5 \textwidth]{img/ClientServer}  \caption{Взаимодействие клиентов с~распределённой системой} \label{clser}
\end{figure}
Когда клиент~$p$ посылает запрос системе, этот запрос сначала обрабатывается координационной инфраструктурой и только после этого отправляется системе. При получении ответа от системы координационная инфраструктура также обрабатывает полученную информацию, а затем отправляет ответ клиенту~$p$. Поэтому клиентская часть операций чтения/записи исполняется на стороне координационной структуры, а не на стороне клиента.

Реализация системы $BTS$ состоит из 4 модулей:
\begin{itemize}
	\item модуль $secondary\_functions$ включает в себя вспомогательные функции,
	\item модуль $client$ реализует клиентский интерфейс,
	\item модуль $infrastructure$ реализует деятельность координационной инфраструктуры,
	\item модуль $server$ реализует деятельность сервера $s \in U$.
\end{itemize}
Рассмотрим реализацию компонент более подробно.

\subsection{Модуль secondary_functions}\label{subsec:2}
Модуль $secondary\_functions$ включает в себя функции сетевого взаимодействия ($get_message$, $send_message$, $connect_to_server$), а также функцию создания и записи пространства кортежей в файл ($create_ts_file$). Реализации данных функций представлены в листинге~\ref{list:secfunc}.

Функции сетевого взаимодействия используют в своей работе возможности модуля $socket$ из стандартной бибилиотеки $Python$~\ref{socket}. Функция $connect_to_server$ принимает в качестве входного параметра порт, к которому необходимо подключиться. При удачном подключении возвращается сокет, который можно использовать для обмена сообщениямив дальнейшей работе, иначе возвращается объект $None$, сигнализирующий о неудаче.

Функция $send_message$ используются для отправки данных по сети, она имеет два входных параметра: сокет, с помощью которого осуществляется отправка сообщения, и само сообщение, которое требуется отправить. Чтобы преобразовать сообщение к виду, пригодному для записи в сокет, используется функция $dumps$ из модуля $pickle$~\ref{pickle}, отвечающая за сериализацию объектов. После завершения операции записи в сокет функция $send_message$ завершает свою работу.

Функция $get_message$ используются для получения данных из сети, она имеет единственный входной параметр~--- сокет, из которого осуществляется чтение информации. Если полученное сообщение оказалось пустым, то возвращается объект $None$, иначе сообщение десериализуется с помощью функции $loads$ из модуля $pickle$ и возвращается функцией $get_message$.

Функция $create_ts_file$ создаёт пространство кортежей и записывает его в файл. Данная функция используется для того, чтобы в дальнейшем каждый сервер системы при запуске смог прочитать информацию из созданного при помощи  $create_ts_file$ файла и сконструировать локальную реплику пространства кортежей. Имя файла, объём создаваемого пространства, а также длина и значения полей входящих в него кортежей регулируются входными параметрами функции. Для преобразования созданного пространства кортежей в удобный формат и записи в файл используется функция $dump$ из модуля $json$~\ref{json}.


\subsection{Модуль client}\label{subsec:3}
Интерфейс пользователя для взаимодействия с $BTS$ реализован с помощью класса $Client$ из модуля $client$ (см.\,листинги~\ref{list:client}~и~\ref{list:client2} в приложении А). Для того, чтобы начать работу, следует создать объект класса $Client$, передав конструктору в качестве входного параметра значение порта, который координационная инфраструктура использует для обмена сообщениями с клиентами.

Далее для исполнения операций чтения/записи нужно вызвать соответствующую функцию: $out_op(t)$, $rd_op(\bar t)$ или $in_op(\bar t)$. Заметим, что операция записи $out_op$ в качестве входного параметра принимает кортеж, а операции чтения $rd_op$ и $in_op$ --- шаблон кортежа. Каждая из этих операций формирует запрос в виде словаря $\{'op': \mbox{код операции}, 'tup': \mbox{кортеж}\}$ или $\{'op': \mbox{код операции}, 'temp': \mbox{шаблон кортежа}\}$, соответствующий её семантике. Сформированный запрос отправляется координационной инфраструктуре. Для завершения операции записи не требуется ответ системы, а операции чтения ожидают, когда инфраструктура вернёт запрошенное значение.

Для корректного завершения работы системы в классе $Client$ реализована функция $stop_op()$, которая отправляет инфраструктуре запрос о прекращении работы и ожидает ответа об успешном результате операции. По смыслу данная функция не должна являться частью клиентского интерфейса, она была включена в класс $Client$ для удобства.

\subsection{Модуль BTS_infrastructure}\label{subsec:4}
 







Теперь опишем протоколы чтения/записи из~языка~$Linda$, но сделаем операции чтения неблокирующими. 

\subsection{Операция записи out}\label{subsec5:1}
Вызов функции~$out(t)$ добавляет кортеж $t$ в~пространство. На~стороне клиента эта операция реализуется с~помощью алгоритма\,\ref{alg1}:

\begin{algorithm}[H]
	\caption{Операция out}\label{alg1}
	\begin{algorithmic}[1]
		\Statex $\{$client $p \}$
		\Procedure{out}{$t$}
		\ForAll {$s \in Q_w$}
			\State \Call{send}{$s, \langle$ OUT, $t \rangle$}
		\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

При~вызове данной функции клиенту~$p$ не~нужно ждать ответа от~серверов. Будем считать, что операция завершится в~тот момент, когда все корректные серверы из~кворума записи получат кортеж~$t$.

На~стороне сервера операция~$out$ реализуется с~помощью алгоритма\,\ref{alg2}:
	
\begin{algorithm}[H]
	\caption{Операция out}\label{alg2}
	\begin{algorithmic}[1]
		\Statex $\{$server $s \}$
		\Upon{receive}{$p, \langle$ OUT, $t \rangle$}
			\If{$t \notin R_s$}
				\State $T_s \gets T_s \cup \{t\}$
			\EndIf
			\State $R_s \gets R_s \setminus \{t\}$
		\EndUpon
	\end{algorithmic}
\end{algorithm}

При~получении запроса~$\langle$~OUT,~$t \rangle$ от~клиента~$p$ сервер~$s$ добавляет кортеж~$t$ в~пространство кортежей только в~том случае, если этот кортеж ранее не~был из~него удалён. Это необходимо для~того, чтобы один и тот же кортеж не~был удалён дважды.

\subsection{Операция чтения rdp}\label{subsec5:2}
Недеструктивная операция чтения~$rdp$ в~качестве входного параментра принимает шаблон кортежа~$\bar t$, возвращает копию соответствующего шаблону кортежа из~пространства. На~стороне клиента эта операция реализуется с~помощью алгоритма\,\ref{alg3}:

\begin{algorithm}[H]
	\caption{Операция rdp}\label{alg3}
	\begin{algorithmic}[1]
		\Statex $\{$client $p \}$
		\Function{rdp}{$\bar t$}
		\State $T[s_1, \dots, s_n] \gets (\perp, \dots, \perp)$
		
		\ForAll {$s \in U$}
		\State \Call{send}{$s, \langle$ RD, $\bar t \rangle$}
		\EndFor
		
		\Repeat
		\State \Wait{receive}{$s, \langle$ TS, $T_s^{\bar t} \rangle$}
		\State $T[s] \gets T_s^{\bar t}$
		\Until{$\{s \in U$ : $T[s] \ne \perp \} \in \mathcal{Q}_r$}
		
		\If{$\exists t$ : ($|s$ : $t \in T[s]| \geqslant f + 1$)}
		\State \Return{$t$}
		\EndIf
		\State \Return{$\perp$}
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Клиент~$p$ взаимодействует с~кворумом серверов чтения, в~качестве ответа на~запрос он получает от~каждого сервера список подходящих под~шаблон кортежей (серверная часть реализуется с~помощью алгоритма\,\ref{alg4}), затем клиент $p$ выбирает из~них общий кортеж~$t$, который располагается как минимум на~$f + 1$ сервере. Если такого кортежа нет, то возвращается спецсимвол~$\perp$, обозначающий, что операция не~увенчалась успехом. Заметим, что операция~$rdp$ не~является блокирующей в~отличие от~её аналога~$rd$ в~языке~$Linda$.

\begin{algorithm}[H]
	\caption{Операция rdp}\label{alg4}
	\begin{algorithmic}[1]
		\Statex $\{$server $s \}$
		\Upon{receive}{$p, \langle$ RD, $t \rangle$}
		\State $T_s^{\bar t} \gets \{t \in T_s$ : $m(t, \bar t)\}$
		\State send(p, $\langle$ TS, $T_s^{\bar t}\rangle$)
		\EndUpon
	\end{algorithmic}
\end{algorithm}

\subsection{Операция чтения inp}\label{subsec5:3}
Операция~$inp$ является операцией деструктивного чтения, она имеет более сложную реализацию, поскольку один кортеж не~может быть удалён из~пространства двумя различными вызовами~$inp$. Этот факт подразумевает использование критических секций для~процессов, пытающихся удалить один и тот же кортеж, что, во-первых, обеспечит невозможность удаления кортежа двумя процессами одновременно, во-вторых, позволит всем процессам получить доступ к~ресурсу в~некоторое время. Операции входа в критическую секцию на~стороне клиента реализуется с~помощью функции~$enter(\bar t)$, описанной в~алгоритме\,\ref{alg5}:

\begin{algorithm}[H]
	\caption{Операция enter}\label{alg5}
	\begin{algorithmic}[1]
		\Statex $\{$client $p \}$
		\Function{enter}{$\bar t$}
		\State $T[s_1, \dots, s_{|Q_r|}] \gets (\perp, \dots, \perp)$
		
		\ForAll {$s \in U$}
		\State \Call{send}{$s, \langle$ ENTER, $p, \bar t \rangle$}
		\State $T[s] \gets T_s^{\bar t}$
		\EndFor
		
		\ForAll {$s \in Q_r$}
		\State \Wait{receive}{$s, \langle$ GO, $p, T_s^{\bar t} \rangle$}
		\State $T[s] \gets T_s^{\bar t}$
		\EndFor
		
		\If{$\exists t$ : ($|s$ : $t \in T[s]| \geqslant f + 1$)}
		\State \Return{$t$}
		\EndIf
		\State \Return{$\perp$}
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Операция~$enter(\bar t)$ имеет входной параметр~--- шаблон кортежа, который требуется удалить в~результате исполнения операции~$inp$. Входной параметр нужен для~того, чтобы совместить операции входа в~критическую секцию и операцию чтения~$rdp$, что позволит уменьшить количество этапов коммуникации на~единицу. Сначала клиент~$p$ отправляет всем серверам запрос на~разрешение войти в~критическую секцию, затем ожидает, когда все серверы из~кворума чтения дадут положительный ответ на~отправленный запрос. При~отправке разрешения войти в~критическую секцию сервер~$s$ также отправляет список подходящих для~удаления кортежей (то~есть соответствующих шаблону~$\bar t$). Далее, как и в~реализации операции~$rdp$, из~всевозможных вариантов, присланных серверами, выбирается и возвращается общий кортеж~$t$, располагающийся хотя бы на~$f + 1$ сервере, иначе возвращается спецсимвол~$\perp$.

Операция выхода из~критической секции~$exit(\bar t)$ на~стороне клиента имеет более простую структуру: клиент~$p$ отсылает всем серверам сообщение о~выходе из~критической секции, не~дожидаясь какого-либо ответа от~них. Реализация данной операции представлена в~алгоритме\,\ref{alg6}:

\begin{algorithm}[H]
	\caption{Операция exit}\label{alg6}
	\begin{algorithmic}[1]
		\Statex $\{$client $p \}$
		\Procedure{exit}{$\bar t$}
		\ForAll {$s \in U$}
		\State \Wait{send}{$s, \langle$ EXIT, $p, \bar t \rangle$}
		\EndFor
		\EndProcedure
	\end{algorithmic}
\end{algorithm}

Рассмотрим операции входа в~критическую секцию и выхода из~неё на~стороне сервера. /здесь будет псевдокод и описание соответствующих алгоритмов/

Теперь рассмотрим реализацию операции~$inp$ (см.\,алгоритм\,\ref{alg9}). В~первую очередь клиент~$p$ пытается войти в~критическую секцию для~удаления подходящего под~шаблон~$\bar t$ кортежа. По~окончании выполнения функции~$enter(\bar t)$ все серверы из~кворума чтения уже разрешили войти в~критическую секцию, а клиент~$p$ уже выбрал конкретный кортеж~$t$ для~удаления.

\begin{algorithm}[H]
	\caption{Операция inp}\label{alg9}
	\begin{algorithmic}[1]
		\Statex $\{$client $p \}$
		\Function{inp}{$\bar t$}
		\Repeat
			\State $t \gets$ \Call{enter}{$\bar t$}
			\If{$t = \perp$}
				\State \Call{exit}{$\bar t$}
				\State \Return{$\perp$}
			\EndIf
			\State $d \gets$ \Call{paxos}{$p, P, A, L, t$}
			\State \Call{exit}{$\bar t$}
		\Until{$d = t$}
		\State \Return{$t$}
		\EndFunction
	\end{algorithmic}
\end{algorithm}

Если выбранный кортеж~$t$ оказался равен спецсимволу~$\perp$, значит в~пространстве кортежей нет ни~одного подходящего под~шаблон~$\bar t$ кортежа, в~этом случае клиент~$p$ выходит из~критической секции, а в~качестве результата возвращается спецсимвол~$\perp$, сигнализирующий о~неудачном завершении операции~$inp$.

Если выбранный кортеж~$t$ не~равен спецсимволу~$\perp$, то клиент~$p$ предлагает серверам удалить именно его. Для~того, чтобы удалить кортеж~$t$, соответствующий шаблону~$\bar{t}$, из~пространства, серверы из~кворума чтения должны принять решение, можно~ли удалить кортеж~$t$. Для~этой цели вызывается функция~$paxos$, являющаяся реализацией алгоритма достижения консенсуса в~распределённых системах. Данная функция имеет пять параметров: 
\begin{enumerate}
	\item Процесс~$p$, предлагающий значение. В~нашем случае это клиентский процесс, вошедший в~критическую секцию.
	\item Множество Заявителей~$P = \{p, s_1, ..., s_{f+1}\}$, состоящее из~клиентского процесса~$p$ и $f + 1$~сервера. Такой набор гарантирует наличие хотя~бы одного корректного заявителя.
	\item Множество Акцепторов~$A = U$. Все серверы являются Акцепторами.
	\item Множество Узнающих~$L = \{p\} \cup U$. О~принятом решении узнают все серверы и клиентский процесс.
	\item Предлагаемое значение~$t$.
\end{enumerate}

В~качестве выходного параметра~$paxos$ возвращает кортеж~$d$, который было принято удалить из~пространства. Далее происходит выход из~критической секции. Если полученное значение~$d$ совпало с~предлагаемым~$t$, то операция~$inp$ завершается и возвращает в~качестве выходного параметра удалённый кортеж~$t$. Если~$d \ne t$, то все вышеописанные выкладки проделываются заново до~тех~пор, пока не~выполнится условие~$d = t$.

На~момент выхода из~функции~$paxos$ все Акцепторы уже приняли решение, удалять кортеж~$t$ или нет, все Узнающие получили сообщения о~решении Акцепторов. Если функция~$paxos$ вернула кортеж, то он уже был удалён из~пространства кортежей, иначе возвращается спецсимвол~$\perp$, сигнализирующий о~том, что операция удаления кортежа~$t$ не~увенчалась успехом. Данный результат иллюстрирует благоприятный и промежуточный исходы задачи византийских генералов. При~благоприятном исходе из~пространства кортежей удаляется кортеж, предложенный клиентом, то~есть приказ главнокомандующего (клиента) был получен и изучен всеми генералами (серверами), после~чего они единогласно приняли решение следовать приказу. При~промежуточном исходе кортеж не~удаляется, возвращается спецсимвол~$\perp$, при~этом сохраняется целостность пространства кортежей, поскольку на~всех корректных серверах удаления не~произошло. Иными словами, генералами (серверами) было принято единогласное решение не~доверять приказу главнокомандующего (клиента) и отступить (не~производить удаление), сохранив при~этом армию (целостность пространства кортежей).

/здесь будет описание серверной части операции inp/

\subsection{Блокирующие операция rd и in}\label{subsec5:4}
Кроме того, операции чтения являются блокирующими, то~есть если в~пространстве кортежей на данный момент нет ни~одного кортежа, соответствующего шаблону, то процесс, пославший запрос, заблокируется до~того момента, пока в~пространстве не~появится подходящего кортежа.

Блокирующие операции $rd$ и $in$, соответствующие спецификации языка~$Linda$, могут быть реализованы на~стороне клиента путём повторного вызова их неблокирующих аналогов $rdp$ и $inp$ до~тех~пор, пока необходимый кортеж не~будет получен.





\Conc

\printbibliography[heading=bibintoc]

\appendix
\ifthenelse{\value{worktype} > 1}{%
	\addtocontents{toc}{%
		\protect\renewcommand{\protect\cftchappresnum}{\appendixname\space}%
		\protect\addtolength{\protect\cftchapnumwidth}{\widthof{\appendixname\space{}} - \widthof{Глава }}%
	}%
}{
\addtocontents{toc}{%
	\protect\renewcommand{\protect\cftsecpresnum}{\appendixname\space}%
	\protect\addtolength{\protect\cftsecnumwidth}{\widthof{\appendixname\space{}}}%
}%
}
\section*{Приложение А}
\addcontentsline{toc}{section}{Приложение А}
\begin{ListingEnv}[H]\caption{Модуль $secondary\_functions$}\label{list:secfunc}
\begin{lstlisting}[language=Python, numbers=left]
from socket import socket, AF_INET, SOCK_STREAM, error
import _pickle as pickle
import json

def get_message(sock):
  sock.settimeout(50)
  msg = b""
  tmp = b""
  while True:
	try:
	  tmp = sock.recv(1024)
	except error:
	  break
	if len(tmp) < 1024:
	  break
	msg += tmp
  msg += tmp
  if len(msg) > 0:
	return pickle.loads(msg)
  else:
	return  None

def send_message(sock, msg):
  sock.send(pickle.dumps(msg))

def connect_to_server(port):
  sock = socket(AF_INET, SOCK_STREAM)
  i = 50
  while i:
	try:
	  sock.connect(('localhost', port))
	except ConnectionRefusedError:
	  i -= 1
	else:
	  return sock
  return None

def create_ts_file(file_name, init_num, amount=500, length=100):
  with open(file_name, 'w') as f:
	list_of_tuples = list()
	for i in range(init_num * amount, (init_num + 1) * amount):
	  list_of_tuples.append(tuple(j for j in range(i, i + length)))
	json.dump(list_of_tuples, f)
	
	\end{lstlisting}
\end{ListingEnv}

\begin{ListingEnv}[p]\caption{Класс $Client$, модуль $client$}\label{list:client}
\begin{lstlisting}[language=Python, numbers=left]
import logging
from secondary_functions import get_message, send_message, connect_to_server

class Client(object):

  def __init__(self, port):
	self.port = port
	logging.basicConfig(filename='client_log.txt', level=logging.DEBUG, format="%(asctime)s - %(message)s")


  def out_op(self, tup):
	sock = connect_to_server(self.port)

	if sock is not None:
	  send_message(sock, {'op': 'out', 'tup': tup})
	  sock.close()
	  logging.info('OUT: ' + str(tup))
	else:
	  logging.info('OUT_OP: cannot connect to server')

	
  def rd_op(self, temp):
	sock = connect_to_server(self.port)

	if sock is not None:
	  send_message(sock, {'op': 'rdp', 'temp': temp})
	  resp = get_message(sock)
	  sock.close()
	  logging.info('RD: ' + str(resp['resp']))

	  if resp is None:
		return resp
	  else:
		return resp['resp']
	else:
	  logging.info('RD_OP: cannot connect to server')
	  return None

\end{lstlisting}
\end{ListingEnv}
\begin{ListingEnv}[p]\caption{Класс $Client$, модуль $client$ (продолжение)}\label{list:client2}
	\begin{lstlisting}[language=Python, numbers=left]
  def in_op(self, temp):
	sock = connect_to_server(self.port)

	if sock is not None:
	  send_message(sock, {'op': 'inp', 'temp': temp})
	  resp = get_message(sock)
	  sock.close()
	  logging.info('In: ' + str(resp['resp']))

	  if resp is None:
		return resp
	  else:
		ret	urn resp['resp']

	else:
	  logging.info('IN_OP: cannot connect to server')
	  return None
	
  def stop_op(self):
	sock = connect_to_server(self.port)

	if sock is not None:
	  send_message(sock, {'op': 'stop'})
	  resp = get_message(sock)
	  sock.close()
	  logging.info('STOP_OP: ' + str(resp['resp']))

	  if resp is None:
		return resp
	  else:
		return resp['resp']

	else:
	  logging.info('STOP_OP: cannot connect to server')
	  return None
	
	\end{lstlisting}
\end{ListingEnv}


\if 0
% Если typeOfWork в SETUP.tex задан как 2 или 3, то начинать
% надо не с section (раздел), а с главы (chapter)
\section{Несколько примеров в~\LaTeX{}}
\label{sec:examples}
\subsection{Как вставлять листинги и рисунки}
Для крупных листингов есть два способа. Первый красивый, но в нём не допускается
кириллица (у вас может встречаться в комментариях и
печатаемых сообщениях), он представлен на листинге~\ref{list:hwbeauty}.
\begin{ListingEnv}[H]% буква H означает Here, t (top, сверху страницы),
% или b (bottom) или p (page, на отдельной странице)
\begin{lstlisting}
#include <iostream>
using namespace std;

int main()
{
    cout << "Hello, world" << endl;
    system("pause");
    return 0;
}
\end{lstlisting}
\caption{Программа “Hello, world” на \protect\cpp}\label{list:hwbeauty}
\end{ListingEnv}

Второй не такой красивый, но без ограничений (см.~листинг~\ref{list:hwplain}).
\begin{ListingEnv}[H]
\begin{Verb}

#include <iostream>
using namespace std;

int main()
{
    cout << "Привет, мир" << endl;
}
\end{Verb}
\caption{Программа “Hello, world” без подсветки}
\label{list:hwplain}
\end{ListingEnv}

Можно использовать первый для вставки небольших фрагментов
внутри текста, а второй для вставки полного
кода в приложении, если таковое имеется.

Если нужно вставить совсем короткий пример кода (одна или две строки), то выделение  линейками и нумерация может смотреться чересчур громоздко. В таких случаях можно использовать окружения \texttt{lstlisting} или \texttt{Verb} без \texttt{ListingEnv}. Приведём такой пример с указанием языка программирования, отличного от заданного по умолчанию:
\begin{lstlisting}[language=Haskell]
fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
\end{lstlisting}
Такое решение~--- со вставкой нумерованных листингов покрупнее
и вставок без выделения для маленьких фрагментов~--- выбрано,
например, в книге Эндрю Таненбаума и Тодда Остина по архитектуре
компьютера~\autocite{TanAus2013} (см.~рис.~\ref{fig:tan-aus}).

Наконец, для оформления идентификаторов внутри строк
(функция \lstinline{main} и тому подобное) используется
\texttt{lstinline} или, самое простое, моноширинный текст
(\texttt{\textbackslash texttt}).

\subsection{Как оформить таблицу}

Для таблиц обычно используются окружения table и tabular --- см. таблицу~\ref{tab:widgets}. Внутри окружения tabular используются специальные команды пакета booktabs — они очень красивые; самое главное: использование вертикальных линеек считается моветоном.

\begin{table}
\centering
\caption{\label{tab:widgets}Подпись к таблице --- сверху}
\begin{tabular}{llr}
\toprule
\multicolumn{2}{c}{Item} \\
\cmidrule(r){1-2}
Животное  & Описание    & Цена (\$) \\
\midrule
Gnat      & per gram    & 13.65      \\
          & each        & 0.01       \\
Gnu       & stuffed     & 92.50      \\
Emu       & stuffed     & 33.33      \\
Armadillo & frozen      & 8.99       \\
\bottomrule
\end{tabular}
\end{table}

\fi

\end{document}
